\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{mdwlist}
\usepackage{wasysym}
\usepackage{fancyhdr}
\usepackage{graphicx}

\usepackage{fancyvrb}
\usepackage{cite}
\usepackage{color}
\usepackage[colorlinks,backref]{hyperref}
\usepackage{minted}

\pagestyle{fancy}
\headheight 35pt
\begin{document}

\lhead{\textbf{CSSE377}}
\rhead{Functional Refactoring \\ November 2010}

\vspace*{60mm}
\begin{center}
{ \huge \textbf{Refactoring Techniques \\ in Functional Languages} } \\
{ \large \textit{Pete Brousalis, Tim Ekl, Tom Most, David Pick, Eric Stokes} }
\end{center}

\newpage{}

\tableofcontents

\newpage{}

\section{Introduction}

Refactoring, the process of rewriting program code, is a generally accepted practice in the programming world. Programmers will refactor for a variety of reasons: to improve code readability, to change program structure, to increase maintainability, and to reduce complexity, among others. However, the majority of existing refactoring techniques, including those put forth by the ``Gang of Four'', focus largely on object-oriented code; furthermore, university curricula tend to focus on those refactoring practices, given the prevalence of object-orientation as a programming paradigm.

Of late, however, functional languages have begun to emerge as strong competitors to their object-oriented peers in a variety of environments. Many large-scale websites such as Facebook and Twitter use functional programming and paradigms in their application stacks; MapReduce, the core of Google's search technology and scalability, has its root in functional technologies; and even object-oriented languages such as Python and Ruby have begun to adopt several functional practices. As the functional paradigm becomes more prominent, coders must be able to apply refactoring techniques to code where the Gang of Four patterns may no longer apply.

This paper provides a brief insight into the state of refactoring in five different functional languages: Clojure, Erlang, Haskell, Scala, and Scheme. The authors review each language and its applications, then provide examples of common refactoring techniques in use with each of these languages, as well as how those techniques relate to the practice of functional programming as a whole.

\section{History}

The concept of functional languages began with the development of lambda calculus, a mathematical concept used to encapsulate certain ideas about computation. The vast majority of functional languages today are based on ideas derived from lambda calculus \cite{combinatorylogic}.

The first true functional language was Lisp, developed in the late 1950s for IBM scientific computers at MIT. Lisp introduced many concepts common to functional languages now, and spawned a number of dialects, including Common Lisp and Scheme \cite{historyoflisp}. Over the next few decades, a small number of prevalent functional languages were introduced, including APL and ML. The early 1990s saw a large increase in the number of functional languages available with the advent of J and K, as well as the beginning of the standardization process for Haskell.

Today, functional languages remain somewhat of a specialty: of the top 20 programming languages in use today, the only functional language to hold a spot is Lisp at \#13, with just over 1\% of existing worldwide production code. However, Scheme, Haskell, ML, APL, and Scala all appear in the top 50 programming languages, and most of these are gaining in popularity \cite{TIOBE}.

\input{Clojure/Clojure.tex}

\input{Erlang/Erlang.tex}

\input{Haskell/Haskell.tex}

\input{Lisp/Lisp.tex}

\input{Scala/Scala.tex}

\section{Conclusion}

Modern functional languages span a wide number of applications and implementation concepts, ranging from the mostly object-oriented to the highly mathematical. As such, the set of refactoring techniques in existence for functional languages varies as well. However, there are a few patterns that can be drawn from the languages discussed above.

Most evident is the concept that languages which approximate object-oriented behavior can be refactored with object-oriented techniques. Languages which provide classes (or an equivalent such as packages) can obviously have methods moved between classes, and so forth. In a similar vein, trivial object-oriented refactoring techniques (e.g. ``extract method'', ``rename variable'') remain in play in functional languages due to the continued existence of methods and variables.

Another prevailing trend is the similarity of some functional refactoring techniques to known mathematical practices. For example, consider the Clojure technique of composing methods: function composition is a common practice in the mathematical world, and currying -- an analogous concept in generic programming -- is taught regularly in computer science courses, primarily as a mathematical exercise. Techniques related to type inference (in languages with support for it) also fall roughly into this category.

Overall, the field of refactoring in the context of functional languages is fairly well developed. While not as ingrained into developers' consciousnesses as the object-oriented equivalent, refactoring techniques in functional languages are widely available, and can serve to improve the quality of code in almost any language.

\bibliography{Bibliography}
\bibliographystyle{plain}

\end{document}