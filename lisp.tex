\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{mdwlist}
\usepackage{wasysym}
\usepackage{fancyhdr}
\usepackage{graphicx}

\pagestyle{fancy}
\headheight 35pt
\begin{document}

\lhead{\textbf{CSSE377 \\ Functional Refactoring}}
\rhead{November 2011 \\ Lisp}

\subsection*{Language Background}

Originally created in 1958, Lisp is the second oldest high-level programming language still in use. The name Lisp comes from 'list processing' as linked-lists are one of the most important data structures in the language, along with the fact that the entire source code for the language is made up of lists. Since List source code is made up of lists, the language allows a developer to manipulate source code as a data structure. This lead to the creation of macro systems which allow programmers to create new syntax, and domain specific languages based on the original Lisp language.

\\A domain specific language is one that is based on a language such as List, but provides specific syntax for handling a specific problem domain. For instance if someone were to modify the original list language with specific functions for creating web applications, they would have created a domain specific language.

\\Lisp and languages based on it can easily be recognized by their extreme use of parenthesis as well as the s-expressions that are used to write in the language. An S-expression or symbolic-expression are list-based data structures, used to represent semi-structured data. A simple example of an S-expression would be (+ 2 2). This S-expression highlights Lisp prefix notation, where unlike most other languages operators come first in the S-expression while everything else is treated as data. The combination of prefix-notation and S-expressions makes Lisp extremely easy to parse and lead to the creation of two extremely well known functions car and cdr. Car returns the first part of an S-expression, while cdr will return the data portion of the S-expression.


\subsection*{Refactoring in Lisp}

Write 3--3.5 pages about refactoring in your particular language. Be sure to include code snippets and follow through the refactoring process of at least one decently-sized chunk of code. You can use

\begin{verbatim}
// code blocks
\end{verbatim}

as well as \verb!inline verbatim! blocks to format code. Don't forget about $math \; markup$ if you're dealing with anything mathy like algorithm analysis or functional composition. Also be sure to cite your sources! (This may require you to compile the paper twice to make the citations work\cite{Item1}.)

\subsection*{Conclusion}

Wrap up your section with a 0.5--1 page conclusion that recaps refactoring in your language and discusses any emerging concepts or practices in your language.

\begin{thebibliography}{9}
\bibitem{Item1} Item One
\end{thebibliography}

\end{document}