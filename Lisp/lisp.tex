\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{mdwlist}
\usepackage{wasysym}
\usepackage{fancyhdr}
\usepackage{graphicx}

\pagestyle{fancy}
\headheight 35pt
\begin{document}

\lhead{\textbf{CSSE377 \\ Functional Refactoring}}
\rhead{November 2011 \\ Lisp}

\section{Lisp}

\subsection{Language Background}

Originally created in 1958, Lisp is the second oldest high-level programming language still in use today. The name Lisp comes from ``list processing'' as linked-lists are one of the most important data structures in the language, along with the fact that the entire source code for the language is made up of lists. Since List source code is made up of lists, the language allows a developer to manipulate source code as a data structure. This lead to the creation of macro systems which allow programmers to create new syntax, and domain-specific languages based on the original Lisp language.

A domain-specific language is one that is based on a language such as Lisp, but provides an extended syntax for handling a specific problem domain. For instance, if someone were to modify the original list language with specific functions for creating web applications, they would have created a domain-specific language.

Lisp and languages based on it can easily be recognized by their extreme use of parenthesis as well as the S-expressions that are used to write in the language. An S-expression or symbolic-expression (commonly referred to as \textit{sexps}) are list-based data structures, used to represent semi-structured data. A simple example of a sexp would be \verb!(+ 2 2)!. This sexp highlights Lisp prefix notation, where unlike most other languages operators come first in the sexp while everything else is treated as data. The combination of prefix-notation and sexps makes Lisp extremely easy to parse and led to the creation of two extremely well known functions: \verb!car! and \verb!cdr!. \verb!car! returns the first part of an sexp, while \verb!cdr! will return the data portion of the sexp.


\subsection{Refactoring in Lisp}

\subsubsection{Extract Function}

One of the easiest programming pitfalls to fall into is the creation of functions that are longer than they need to be or should be. While there are several reasons that a developer should attempt to write shorter methods, the first and most important is that it increases the likelihood that other functions can use a function. This one simple refactoring technique will allow higher level functions to read much better since they will call well named functions which can actually be read, similarly to how a comment would. While this idea does take some getting used to if a developer is used to writing longer functions, the addition of small functions with good, clear names will greatly improve the readability, modifiability, and understandability of a code base. Consider this Lisp snippet:

\begin{verbatim}
(defun list-to-comma-delimited-string (list)
  (let ((output (format nil "~A" (car list))))
    (dolist (elem (cdr list))
      (setq output 
        (concatenate 'string output "," 
          (format nil "~A" elem)))))
\end{verbatim}

This function is a good example of one that is trying to do too much. By calling a second function designed for the formatting of strings, the developer can make the original function much easier to read and understand:

\begin{verbatim}
(defun list-to-comma-delimited-string (list)
  (format nil "~{~A~^,~}" list))
\end{verbatim}

\subsubsection{Rename Function / Variable}

The first refactoring technique introduced in this section was the idea of short functions. However, in order for short functions to work properly as a refactoring technique, all functions and variables must be named in a clear manner that gives the developer an idea of their purpose. Functions need to be named in such a way that communicates their intention. A good way to do this is to think of what a comment would be for a function and try and incorporate that into the name of the function. This is an extremely important technique that can take some time to master. While attempting to understand this technique, a developer should not be happy with their first attempt at naming a function. If it is clear that a function will end up preforming a different function from when it was named, simply change the name. The developer must remember that the code they are writing is meant for humans to read, and the best way to make their code understanding is through well named functions and variables. 

A simple example of this would be the following function:

\begin{verbatim}
(defun rev (L)
  (let ((return-value '()))
    (dolist (e L) (push e return-value))
    return-value))
\end{verbatim}

While after reading the code for this function, it may be apparent that it reverses a list, reading a call to this function from another one would not make that fact obvious. This means that as a developer is reading a function which calls this one, they will be forced to read the code for this function to understand the one they are currently looking at. This will tend to break their train of thought and force them to spend a significant amount of extra time reading code that could have been avoided through a function name that made sense.

\begin{verbatim}
(defun reverse-list (list)
  (let ((return-value '()))
    (dolist (e list) (push e return-value))
    return-value))
\end{verbatim}

By naming the function reverse-list instead of rev, it becomes apparent that this function will reverse the passed in list without having to look at the code for it.

Along the same lines, it is just as important to name variables inside of functions well. By naming a variable in clear manner, a developer can make his application much more readable. In Lisp, it is very common to create a variable to pass to a recursive function to act as an accumulator. While the developer has the choice to name this variable whatever they want it can often be helpful to name it something that makes it obvious to another developer that this variable is the accumulator. Looking at the same reverse list function as before we can see this.

\begin{verbatim}
(defun reverse-list (list)
  (let ((r '()))
    (dolist (e list) (push e r))
    r))
\end{verbatim}

In this function the variable \verb!r! acts as the accumulator for the function. However, it is very difficult to figure this out in the function, and once a developer has determined that \verb!r! is the value to be returned, it can be difficult for them to remember that each time they see the variable. In order to combat this issue, a developer should attempt to name their variables in a clear way:

\begin{verbatim}
(defun reverse-list (list)
  (let ((return-value '()))
    (dolist (e list) (push e return-value))
    return-value))
\end{verbatim}

This refactored function is much easier to understand than the first version -- it is very apparent what the purpose of the \verb!return-value! variable is.

\subsubsection{Code Organization}

One of the simplest yet most powerful refactoring techniques is simply how the code is formatted in a file. In Lisp, since every function called must be made in a set of parentheses, it becomes quite easy to miss where one set of parentheses beings and another ends. In order to avoid this confusion, formatting the code such that new function calls appear on a new line and are indented greatly aids in improving the readability of the code. Consider this Lisp code, line-broken only to fit on the page:

\begin{verbatim}
(fomus :output '(:lilypond :view t) :parts (list (make-part :name 
"Piano" :instr :piano :events (loop repeat 10 for off = (random 
30.0) and dur = (1+ (random 3.0)) collect (make-note :off off :dur 
dur :note (+ 60 (random 25)))))))
\end{verbatim}

While this is in fact valid Lisp code, it is extremely difficult to read and understand. By simply adding in a few line breaks and tabs, we can end up with a function that is much clearer.

\begin{verbatim}
(fomus
 :output '(:lilypond :view t)
 :parts
 (list
  (make-part
   :name "Piano"
   :instr :piano
   :events
   (loop repeat 10
	 for off = (random 30.0)
	 and dur = (1+ (random 3.0))
	 collect (make-note :off off :dur dur :note (+ 60 (random 25)))))))
\end{verbatim}

\subsection{Conclusion}

Wrap up your section with a 0.5--1 page conclusion that recaps refactoring in your language and discusses any emerging concepts or practices in your language.

\begin{thebibliography}{9}
\bibitem{Item1} Item One
\end{thebibliography}

\end{document}
