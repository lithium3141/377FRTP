\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{mdwlist}
\usepackage{wasysym}
\usepackage{fancyhdr}
\usepackage{graphicx}

\pagestyle{fancy}
\headheight 35pt
\begin{document}

\lhead{\textbf{CSSE377 \\ Functional Refactoring}}
\rhead{November 2011 \\ Clojure}

Clojure is a dialect of Lisp, developed as a functional companion to Java that targets existing Java Virtual Machines (JVMs) and is therefore compatible with preexisting Java projects. 

\subsection*{Language Background}

Clojure first appeared in 2007 as a personal project of Rich Hickey, who explained that he wanted a language which:

\begin{itemize*}
\item was a Lisp dialect
\item supported functional programming paradigms
\item was ``symbiotic'' with an existing, established platform
\item was designed for concurrency
\end{itemize*}

No such language existed to Hickey's satisfaction, and thus Clojure was born. Since inception, Clojure has rapidly expanded to become a complete Lisp dialect, unconstrained by what Hickey calls the ``slow innovation'' of both Common Lisp and Scheme since their respective standardizations. Since Clojure is not restricted by the scope of those dialects' standards, it can become a more flexible language, so long as it adheres to the JVM specification in compilation.

Clojure is a compiled language. Once written, Clojure code is converted to JVM bytecode that can be natively interpreted by any JVM, including the Sun standard virtual machines. As compiled, it supports the complete Java specification, including type hinting and inference; it avoids reflection where possible. 

\subsection*{Refactoring in LANGUAGE}

Write 3--3.5 pages about refactoring in your particular language. Be sure to include code snippets and follow through the refactoring process of at least one decently-sized chunk of code. You can use

\begin{verbatim}
// code blocks
\end{verbatim}

as well as \verb!inline verbatim! blocks to format code. Don't forget about $math \; markup$ if you're dealing with anything mathy like algorithm analysis or functional composition.

\subsection*{Conclusion}

Wrap up your section with a 0.5--1 page conclusion that recaps refactoring in your language and discusses any emerging concepts or practices in your language.

\begin{thebibliography}{9}
\bibitem{Item1} Item One
\end{thebibliography}

\end{document}
