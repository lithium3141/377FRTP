\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{mdwlist}
\usepackage{wasysym}
\usepackage{fancyhdr}
\usepackage{graphicx}

\pagestyle{fancy}
\headheight 35pt
\begin{document}

\lhead{\textbf{CSSE377 \\ Functional Refactoring}}
\rhead{November 2011 \\ Clojure}

\section{Clojure}

Clojure is a dialect of Lisp, developed as a functional companion to Java that targets existing Java Virtual Machines (JVMs) and is therefore compatible with preexisting Java projects. 

\subsection{Language Background}

Clojure first appeared in 2007 as a personal project of Rich Hickey, who explained that he wanted a language which:

\begin{itemize*}
\item was a Lisp dialect
\item supported functional programming paradigms
\item was ``symbiotic'' with an existing, established platform
\item was designed for concurrency
\end{itemize*}

No such language existed to Hickey's satisfaction, and thus Clojure was born. Since inception, Clojure has rapidly expanded to become a complete Lisp dialect, unconstrained by what Hickey calls the ``slow innovation''\cite{1} of both Common Lisp and Scheme since their respective standardizations. Since Clojure is not restricted by the scope of those dialects' standards, it can become a more flexible language, so long as it adheres to the JVM specification in compilation.

Clojure is a compiled language. Once written, Clojure code is converted to JVM bytecode that can be natively interpreted by any JVM, including the Sun standard virtual machines. As compiled, it supports the complete Java specification, including type hinting and inference; it avoids reflection where possible.

Furthermore, as a Lisp dialect, Clojure is highly functional. It contains a lambda calculus core, and extends the paradigm of ``code as data'' to Java maps and vectors. All data types implemented in Clojure are immutable and persistent, making both recursion and concurrency easy and reliable.

Finally, Clojure adheres to Java's polymorphic behavior, providing the ability to subclass and abstract certain parts of written code. It does not provide its own class system, instead preferring to provide many methods that operate on a relatively small number of classes and objects. Hickey asserts that ``inheritance is \textit{not} the only way to do polymorphism''\cite{1}, and attempts to get away from the object-oriented paradigm while still embracing the underlying Java platform.

\subsection{Refactoring in Clojure}

As with most functional languages, Clojure is not subject to the usual set of refactoring techniques available for object-oriented architectures. Instead, Clojure has developed its own set of potential refactorings, nurtured and encouraged by Hickey.

\subsubsection{Rename refactoring}

One of the simplest refactoring techniques available in Clojure is a simple rename. 

\subsection{Conclusion}

Wrap up your section with a 0.5--1 page conclusion that recaps refactoring in your language and discusses any emerging concepts or practices in your language.

\begin{thebibliography}{9}
\bibitem{1} Hickey, Richard. "Clojure: Rationale." Clojure - Rationale. Web. 28 Oct. 2010. \verb!<http://clojure.org/rationale>!.
\end{thebibliography}

\end{document}
